package org.jugru.miniJUnit;import org.jugru.miniJUnit.annotations.Test;import org.jugru.miniJUnit.exceptions.AssertionException;import org.jugru.miniJUnit.helpers.ClassFinder;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.*;import java.util.regex.Pattern;import java.util.stream.Collectors;import java.util.stream.Stream;public class Core {    private static final String CURRENT_PACKAGE = "org.jugru.miniJUnit";    private static final Pattern package3LevelPattern = Pattern.compile("^[a-z]+\\.[a-z]+\\.[a-zA-Z]+$");    public static void main(String[] args) {        String packageToScan = Arrays.stream(args)                .filter(a -> package3LevelPattern.matcher(a).matches())                .findFirst()                .orElse(CURRENT_PACKAGE);        List<Result> results = runTests(packageToScan);        System.out.println("Total methods found " + results.size());        results.forEach(System.out::println);    }    public static List<Result> runTests(String packageName) {        return                ClassFinder.findAllClassesInPackage(packageName)                .stream()                .flatMap(aClass -> Stream.of(aClass.getDeclaredMethods()))                .filter(method -> method.isAnnotationPresent(Test.class))                .filter(method -> method.getReturnType().equals(Void.TYPE))                .filter(method -> method.getParameterCount() == 0)                .filter(method -> Modifier.isPublic(method.getModifiers()))                .flatMap(method -> {                    try {                        getClass(method).ifPresent(obj -> {                            try {                                    method.invoke(obj);                            } catch  (InvocationTargetException e) {                                if(e.getCause().getClass().equals(AssertionException.class)) {                                    throw new AssertionException(e.getCause().getMessage());                                }                                e.printStackTrace();                            } catch (IllegalAccessException e) {                                e.printStackTrace();                            }                        });                    } catch (AssertionException ae) {                        return Stream.of(Result.ofFalse(method.getName(), ae.getMessage()));                    }                    return Stream.of(Result.ofTrue(method.getName()));                }).collect(Collectors.toList());    }    private static Optional<Object> getClass(Method method) {        Class<?> declaringClass = method.getDeclaringClass();        return Arrays.stream(declaringClass.getConstructors())                .filter(constructor -> Modifier.isPublic(constructor.getModifiers()))                .filter(constructor -> constructor.getParameterCount() == 0)                .findFirst()                .flatMap(constructor -> {                    try {                        return Optional.of(constructor.newInstance());                    } catch (InstantiationException | InvocationTargetException | IllegalAccessException e) {                        e.printStackTrace();                    }                    return Optional.empty();                });    }}